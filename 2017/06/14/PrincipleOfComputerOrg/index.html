<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>the review of the Principle of Computer Organization | blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="第1章 计算机性能指标 机器字长——计算机一次整数运算能够处理的二进制数据的位数 主频、时钟周期 CPI（每条指令周期数）——Clock cycle Per Instruction MIPS（每秒执行多少百万条定点指令数）——Million Instructions Per Second FLOPS（每秒执行浮点操作的次数）   传统冯诺依曼体系是单指令流和单数据流系统 存储器 运算器 控制器 输">
<meta name="keywords" content="review">
<meta property="og:type" content="article">
<meta property="og:title" content="the review of the Principle of Computer Organization">
<meta property="og:url" content="https://lujiamin.github.io/2017/06/14/PrincipleOfComputerOrg/index.html">
<meta property="og:site_name" content="blog">
<meta property="og:description" content="第1章 计算机性能指标 机器字长——计算机一次整数运算能够处理的二进制数据的位数 主频、时钟周期 CPI（每条指令周期数）——Clock cycle Per Instruction MIPS（每秒执行多少百万条定点指令数）——Million Instructions Per Second FLOPS（每秒执行浮点操作的次数）   传统冯诺依曼体系是单指令流和单数据流系统 存储器 运算器 控制器 输">
<meta property="og:updated_time" content="2017-06-14T11:09:50.665Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="the review of the Principle of Computer Organization">
<meta name="twitter:description" content="第1章 计算机性能指标 机器字长——计算机一次整数运算能够处理的二进制数据的位数 主频、时钟周期 CPI（每条指令周期数）——Clock cycle Per Instruction MIPS（每秒执行多少百万条定点指令数）——Million Instructions Per Second FLOPS（每秒执行浮点操作的次数）   传统冯诺依曼体系是单指令流和单数据流系统 存储器 运算器 控制器 输">
  
    <link rel="alternate" href="/atom.xml" title="blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://lujiamin.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-PrincipleOfComputerOrg" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/14/PrincipleOfComputerOrg/" class="article-date">
  <time datetime="2017-06-14T11:00:00.000Z" itemprop="datePublished">2017-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      the review of the Principle of Computer Organization
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第1章"><a href="#第1章" class="headerlink" title="第1章"></a>第1章</h2><ul>
<li>计算机性能指标<ul>
<li>机器字长——计算机一次整数运算能够处理的二进制数据的位数</li>
<li>主频、时钟周期</li>
<li>CPI（每条指令周期数）——Clock cycle Per Instruction</li>
<li>MIPS（每秒执行多少百万条定点指令数）——Million Instructions Per Second</li>
<li>FLOPS（每秒执行浮点操作的次数）</li>
</ul>
</li>
<li>传统冯诺依曼体系是单指令流和单数据流系统<ul>
<li>存储器</li>
<li>运算器</li>
<li>控制器</li>
<li>输入设备</li>
<li>输出设备</li>
<li>相关特点<ul>
<li>指令和数据按地址寻访</li>
<li>二进制代码<a id="more"></a></li>
</ul>
</li>
</ul>
</li>
<li>计算机功能部件<ul>
<li>主存储器<ul>
<li>MAR(地址寄存器)，其位数对应存储单元的个数</li>
<li>MDR(数据寄存器)，其位数和存储字长相等</li>
</ul>
</li>
<li>控制器<ul>
<li>IR(指令寄存器)，存放当前指令</li>
<li>PC(程序计数器)，存放当前欲执行指令的地址</li>
<li>CU(控制单元)  </li>
</ul>
</li>
<li>运算器<ul>
<li>核心是ALU(算术逻辑单元)，包含ACC(累加器)，IX(变址寄存器)，BR(基址寄存器)…</li>
</ul>
</li>
</ul>
</li>
<li>计算机能够直接执行的语言是：机器语言</li>
<li>用助记符编写的语言是：汇编语言</li>
<li>把汇编语言源程序转变为机器语言的过程称为：汇编</li>
</ul>
<h2 id="第2章"><a href="#第2章" class="headerlink" title="第2章"></a>第2章</h2><ul>
<li>进制的转换</li>
<li>校验码<ul>
<li>奇偶校验码<ul>
<li>只能发现数据代码中奇数位出错情况，但不能纠正错误</li>
</ul>
</li>
<li>海明码<ul>
<li>能够自动指出因为错误并纠错</li>
<li>n+k &lt;= 2^k-1，其中n：信息位位数，k：校验位位数</li>
<li>校验位分布在2^(i-1)位置上，即(1,2,4,8…)</li>
<li>校验位（P1，P2，P3…）的计算<ul>
<li>将数据位编成二进制，P1对应个位为1的数据位值的异或，P1对应十位为1的数据位值的异或…</li>
</ul>
</li>
<li>校验原理<ul>
<li>将整个海明码的每一位编成响应二进制数，对个位为1的海明码值求异或…，如果最终每一位对应的异或值都为0，则代表没有出错      </li>
</ul>
</li>
</ul>
</li>
<li>循环冗余校验码(CRC)<ul>
<li>原信息码补0，0的个数为多项式最高次数的值</li>
<li>补完0之后对多项式系数构成的二进制做除法取余</li>
<li>余数加至原信息码后面构成循环冗余码</li>
</ul>
</li>
</ul>
</li>
<li>定点数的表示<ul>
<li>原码（8位表示范围-127~127，存在+0和-0）</li>
<li>反码（8位表示范围-127~127，存在+0和-0）</li>
<li>补码（8位表示范围-128~127，0有唯一补码）</li>
<li>移码——补码符号位取反（8位表示范围-128~127），移码直观上反应真值大小</li>
<li>双符号位加减运算<ul>
<li>00，结果为正数，无溢出</li>
<li>01，正溢出</li>
<li>10，负溢出</li>
<li>11，结果为负数，无溢出</li>
</ul>
</li>
<li>原码一位乘法<ul>
<li>符号位和数值位分开</li>
<li>对应位为1则累加|x|，移位。对应位为0，则累加0，移位。</li>
</ul>
</li>
<li>补码一位乘法（Booth算法）<ul>
<li>符号位参与运算</li>
<li>乘数末尾补0，根据最后两位的值来判断操作</li>
<li>00——右移一位</li>
<li>01——累加[x]补，右移一位</li>
<li>10——累加[-x]补，右移一位</li>
<li>11——右移一位 </li>
<li>补码转化为真值</li>
</ul>
</li>
</ul>
</li>
<li>浮点数的表示<ul>
<li>IEEE754标准<ul>
<li>单精度（32位）：1位符号位（s）+8位阶码（E）+23位尾数（M）</li>
<li>E = 指数(e) + 127</li>
<li>1.M(隐藏为1的尾数)</li>
</ul>
</li>
<li>加减法<ul>
<li>0操作数检查</li>
<li>对阶——小阶向大阶对齐</li>
<li>尾数求和</li>
<li>规格化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第3章"><a href="#第3章" class="headerlink" title="第3章"></a>第3章</h2><ul>
<li>在计算机中的层次<ul>
<li>主存(内存)</li>
<li>辅存(外存)</li>
<li>高速缓冲存储器(cache)</li>
<li>cache——主存：解决速度问题，数据调动由硬件完成，对程序员透明</li>
<li>主存——辅存：解决容量问题，数据调动由硬件和操作系统完成，对应用程序员透明</li>
</ul>
</li>
<li>存储器的分类<ul>
<li>存储介质<ul>
<li>磁表面（磁带，磁盘）</li>
<li>磁芯半导体</li>
<li>光存储器（光盘）</li>
</ul>
</li>
<li>存取方式<ul>
<li>随机存储器</li>
<li>顺序存储器（磁带）</li>
<li>直接存储器（磁盘）——介于两者之间</li>
</ul>
</li>
<li>内容的可保存性<ul>
<li>ROM(只读存储器)</li>
<li>RAM(随机读写存储器)</li>
</ul>
</li>
</ul>
</li>
<li>存储器的性能指标<ul>
<li>存储容量、单位成本、存储速度</li>
<li>存储速度<ul>
<li>存取时间——启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间</li>
<li>存取周期——进行一次完整的读写操作所需的时间。即连续两次独立地访问存储器之间所需的最小时间间隔</li>
<li>通常：存储周期 &gt; 存取时间，原因是在读写操作之后有一段恢复内部状态的复原时间</li>
</ul>
</li>
<li>主存带宽——数据传输率 </li>
</ul>
</li>
<li>SRAM<ul>
<li>地址线 （字数）</li>
<li>数据线 （位数）</li>
<li>读写控制线</li>
</ul>
</li>
<li>DRAM<ul>
<li>刷新方式<ul>
<li>集中式刷新，利用一个固定的时间，对存储器的所有行进行逐一再生，这期间停止对存储器的读写操作</li>
<li>分散式刷新，没有死区</li>
</ul>
</li>
<li>存储器容量的扩充</li>
</ul>
</li>
<li>ROM<ul>
<li>掩模ROM</li>
<li>可编程ROM（PROM,EPROM,E2PROM）</li>
</ul>
</li>
<li>FLASH存储器<ul>
<li>是在EPROM上发展而来</li>
</ul>
</li>
<li>并行存储器<ul>
<li>双端口存储器<ul>
<li>左右两个独立的端口，具有相互独立的地址线、数据线和读写控制线</li>
<li>当两个端口的地址不相同时，两个端口进行读写操作一定不会发生冲突</li>
<li>使用同一个地址单元时，会造成冲突</li>
</ul>
</li>
<li>多模块交叉存储器<ul>
<li>高位交叉编址仍是顺序存储器</li>
<li>低位交叉编址则是交叉存储器</li>
<li>顺序方式：t = mT</li>
<li>交叉方式：t = T + (m-1)τ （其中T=mτ）</li>
<li>模块数必须大于等于m</li>
</ul>
</li>
</ul>
</li>
<li>cache<ul>
<li>cache命中率（h）</li>
<li>cache访问时间（Tc）</li>
<li>访问效率（e=Tc/Ta）</li>
<li>平均访问时间（Ta）</li>
<li>主存和cache的地址映射<ul>
<li>由于cache容量很小，需要将主存地址定位到cache中</li>
<li>全相联——可以装入cache中的任意位置<ul>
<li>地址结构：主存字块标记+字块内标记</li>
</ul>
</li>
<li>直接映射——主存数据块只能装入cache中的唯一位置。<ul>
<li>j = i % N （j：cache块号，i：主存块号，N：cache总块数）</li>
<li>地址结构：主存字块标记+cache字块标记+字块内地址</li>
</ul>
</li>
<li>组相联——组间直接映射，组内全相联<ul>
<li>地址结构：主存字块标记+组号+字块内地址</li>
</ul>
</li>
</ul>
</li>
<li>cache中主存块的替换算法<ul>
<li>LRU（最近最少使用）</li>
<li>LFU（最不经常使用）</li>
<li>随机替换</li>
</ul>
</li>
<li>cache的写操作策略<ul>
<li>写回法——CPU写命中cache时，只修改cache的内容，此行被换出时才写回主存</li>
<li>全写法——CPU写命中时，cache和主存同时发生写修改</li>
<li>写一次法——第一次写命中时同时写入主存</li>
</ul>
</li>
</ul>
</li>
<li>虚拟存储器<ul>
<li>逻辑地址和物理地址</li>
<li>页式虚拟存储<ul>
<li>虚拟空间和主存空间被划分成同样大小的页</li>
<li>页表——存放虚页号和实页号的对照表，一般放在内存中</li>
<li>查页表，需要访问一次主存</li>
</ul>
</li>
<li>段式虚拟存储<ul>
<li>段是按程序的逻辑结构来划分的，段的长度不一致</li>
<li>段号+段内地址</li>
</ul>
</li>
<li>段页式虚拟存储<ul>
<li>分段，每段在划分为相同大小的页</li>
<li>段号+段内页号+页内地址</li>
</ul>
</li>
<li>TLB（快表）——经常需要访问的页对应的页表放在高速缓冲器中</li>
<li>Page（慢表）——放在主存中的页表</li>
<li>TLB是Page的一个很小的副本</li>
<li>TLB命中，Page一定命中</li>
<li>Page不命中，cache和主存也不命中</li>
</ul>
</li>
</ul>
<h2 id="第4章"><a href="#第4章" class="headerlink" title="第4章"></a>第4章</h2><h4 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h4><ul>
<li>操作码</li>
<li>地址码</li>
<li>指令的长度——一条指令中包含二进制代码的位数</li>
<li>指令字长=操作码长度+地址码长度<ul>
<li>机器字长——计算机能够直接处理的二进制数据的位数，决定了计算机的精度。通常和主存单元的位数一致</li>
<li>单字长指令：指令长度=1*机器字长</li>
<li>双字长指令：指令长度=2*机器字长</li>
</ul>
</li>
<li>零地址指令、一地址指令、二地址指令、三地址指令、四地址指令</li>
<li>二地址指令根据操作数的物理位置<ul>
<li>存储器——存储器（SS）</li>
<li>寄存器——寄存器（RR）</li>
<li>寄存器——存储器（RS）</li>
</ul>
</li>
<li>若指令字长32位，操作码8位，一个地址字段占24位，则指令操作数的直接寻址范围为2^24=16M </li>
<li>指令周期——执行一条指令所需要的时间</li>
</ul>
<h4 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h4><ul>
<li>指令的寻址方式<ul>
<li>顺序寻址——使用程序计数器PC来计数</li>
<li>跳跃寻址</li>
</ul>
</li>
<li>数据的寻址方式<ul>
<li>隐含寻址——累加器ACC对单地址指令来说是隐含地址</li>
<li>立即数寻址——指令执行时间最短</li>
<li>直接寻址——形式地址A就是操作数的真实地址，即EA=A</li>
<li>间接寻址——指令的地址字段给出的是操作数有效地址所在存储单元的地址，即EA=(A)</li>
<li>寄存器寻址——在指令字中直接给出操作数所在寄存器的编号，EA=Ri</li>
<li>寄存器间接寻址——寄存器Ri中给出的是操作数所在主存单元的地址，EA=(Ri)</li>
<li>偏移寻址 <ul>
<li>相对寻址——PC的内容加上指令中形式地址A形成操作数的有效地址，EA=(PC)+A</li>
<li>基址寻址——基址寄存器BR的内容加上形式地址A形成操作数的有效地址，EA=(BR)+A</li>
<li>变址寻址——变址寄存器IX的内容加上形式地址A形成操作数的有效地址，EA=(IX)+A</li>
</ul>
</li>
<li>堆栈寻址 </li>
</ul>
</li>
</ul>
<h4 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h4><ul>
<li>复杂指令系统计算机CISC<ul>
<li>指令数目多</li>
<li>指令长度不一致、格式多、寻址方式不一致</li>
<li>使用频率相差较大</li>
<li>执行时间相差较大</li>
<li>控制器大多采用微程序控制 </li>
</ul>
</li>
<li>精简指令系统计算机RISC<ul>
<li>选取高频率使用的一些简单指令</li>
<li>长度固定、格式少、寻址方式少</li>
<li>只有load/store指令访存，其余指令在寄存器之间进行</li>
<li>CPU通用寄存器相当多</li>
<li>以硬布线控制为主、组合逻辑控制</li>
<li>采用指令流水线技术，大多在一个时钟周期内完成</li>
</ul>
</li>
</ul>
<h2 id="第5章"><a href="#第5章" class="headerlink" title="第5章"></a>第5章</h2><ul>
<li>CPU功能<ul>
<li>指令控制</li>
<li>操作控制</li>
<li>时间控制</li>
<li>数据加工</li>
<li>中断处理</li>
</ul>
</li>
<li>CPU组成<ul>
<li>运算器<ul>
<li>ALU、通用寄存器、数据缓冲寄存器、PSW</li>
</ul>
</li>
<li>控制器<ul>
<li>PC、IR、MAR、MDR、指令译码器</li>
</ul>
</li>
</ul>
</li>
<li>主要寄存器<ul>
<li>DR（数据缓冲寄存器）——暂时存放ALU运算结果</li>
<li>IR（指令寄存器）——保存当前正在执行的一条指令</li>
<li>PC（程序计数器）——保存下一条要执行的指令</li>
<li>AR（数据地址寄存器）——保存所访问数据cache存储器中单元的地址</li>
<li>通用寄存器</li>
<li>PSW（状态字寄存器）——各种条件代码（进位标志、溢出标志）</li>
</ul>
</li>
<li>数据通路<ul>
<li>数据在功能部件之间传送的路径称为数据通路</li>
<li>数据通路基本结构<ul>
<li>CPU内部单总线</li>
<li>CPU内部三总线</li>
<li>专用数据通路方式</li>
</ul>
</li>
</ul>
</li>
<li>指令周期<ul>
<li>构成：取指周期+间址周期+执行周期+中断周期，4个过程都有访存操作，目的不同<ul>
<li>取指：取指令</li>
<li>间址：取有效地址</li>
<li>执行：取操作数</li>
<li>中断：保存程序断点</li>
</ul>
</li>
<li>指令周期 &gt; 机器周期 &gt; 时钟周期(节拍T) </li>
<li>时钟周期是CPU操作的最基本单位</li>
<li>各指令的指令周期（MOV,LAD,ADD,STO,JMP）</li>
</ul>
</li>
<li>控制方式<ul>
<li>控制器的控制方式——控制不同操作序列时序信号的方法</li>
<li>同步控制</li>
<li>异步控制</li>
<li>联合控制</li>
</ul>
</li>
<li>控制器<ul>
<li>硬布线控制器，又称组合逻辑控制器，由复杂的组合逻辑门电路和触发器构成<ul>
<li>速度相对较快，原因是微程序控制每条微指令需要从控存中读取一次，影响速度，硬布线主要取决于电路延迟</li>
</ul>
</li>
<li>微程序控制器<ul>
<li>微命令——控制部件通过控制线向执行部件发送各种控制命令</li>
<li>微操作——执行部件接收微命令后进行的操作</li>
<li>微操作在执行部件中是最基本的操作<ul>
<li>相容性——同一个CPU周期内能够并行执行</li>
<li>相斥性——不能并行执行</li>
</ul>
</li>
<li>微指令——在一个CPU周期内，实现一定操作功能的微命令的组合，构成一条微指令</li>
<li>微程序——一条机器指令由多条微指令组成的序列来实现  </li>
<li>微程序控制器原理图<ul>
<li>控制存储器——用来存放实现全部指令系统的微程序</li>
<li>微指令寄存器</li>
<li>地址转移逻辑</li>
</ul>
</li>
<li>微指令周期——读出微指令的时间加上执行该条微指令的时间</li>
<li>为了保证整个机器控制信号的同步，可以将微指令周期设计成CPU周期时间相等</li>
<li>机器指令和微指令的关系<ul>
<li>一条及其指令对应一个微程序，微程序由若干微指令序列构成</li>
<li>机器指令与内存存储器相关，微指令和控制存储器相关</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>微程序设计是利用软件方法来设计硬件的一门技术  <ul>
<li>目标<ul>
<li>缩短微指令的长度</li>
<li>减小控制存储器的容量</li>
<li>提高微程序运行速度</li>
<li>有利于对微指令的修改</li>
<li>提高微程序设计的灵活性</li>
</ul>
</li>
<li>微指令编码<ul>
<li>直接表示法<ul>
<li>控制字段中的每一位表示一个微命令</li>
<li>优点：简单直观、便于直接用于控制</li>
<li>缺点：指令较长，是控制存储器容量较大</li>
</ul>
</li>
<li>编码表示法<ul>
<li>把互斥性微命令编为一组</li>
<li>对微命令进行编码，流出一个代码表示本段不发出微命令</li>
<li>增设微命令译码器</li>
</ul>
</li>
<li>混合表示法</li>
</ul>
</li>
<li>微指令的地址形成方法<ul>
<li>初始微地址的形成<ul>
<li>根据机器指令的操作码形成</li>
</ul>
</li>
<li>后继微地址的形成<ul>
<li>计数器方式，直接由微指令的下地址字段给出 <ul>
<li>简单、功能较弱、速度慢</li>
</ul>
</li>
<li>多路转移方式<ul>
<li>灵活、速度快、设计较为复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>微指令格式<ul>
<li>水平型微指令<ul>
<li>一次能定义并执行多个并行操作微命令的微指令</li>
<li>控制字段+判别测试字段+下地址</li>
</ul>
</li>
<li>垂直型<ul>
<li>微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能</li>
</ul>
</li>
<li>两者的比较<ul>
<li>水平型微指令并行操作能力强，效率高，灵活性强</li>
<li>水平型微指令执行一条指令的时间短</li>
<li>水平型微指令解释的指令的微程序，有微指令字较长而微程序较短的特点</li>
<li>垂直型微指令则相反，微指令字较短而微程序长</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>流水线<ul>
<li>线性流水线的时钟周期：τ=max{τi}+τl（其中τi表示过程段Si所需时间，τl表示延时）</li>
<li>k级过程段完成n个任务，流水线处理所需时钟周期数:T=k+(n-1)。而串行则需要时钟周期数：T=n*k</li>
<li>分类<ul>
<li>指令流水线</li>
<li>算术流水线</li>
<li>处理机流水线</li>
</ul>
</li>
<li>流水线中的主要问题<ul>
<li>资源相关——争用同一个功能部件所发生的冲突</li>
<li>数据相关——一条指令必须等另一条指令执行完才能执行</li>
<li>控制相关——由转移指令引起（执行转移指令后，可能顺序执行下一条，也可能转移到新的目标地址）<ul>
<li>延迟转移法</li>
<li>转移预测法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第6章"><a href="#第6章" class="headerlink" title="第6章"></a>第6章</h2><ul>
<li>总线<ul>
<li>总线是一组能为多个部件分时共享的公共信息传送线路</li>
<li>分时——同一时刻只允许有一个部件向总线发送信息</li>
<li>共享——某一时刻可以有多个部件从总线上接收信息</li>
</ul>
</li>
<li>总线分类<ul>
<li>片内总线（内部总线）——CPU内部连接各个寄存器和运算器的总线</li>
<li>系统总线——计算机系统内各部件（CPU，主存）之间连接的总线<ul>
<li>数据总线，双向传输</li>
<li>地址总线，单向传输</li>
<li>控制总线</li>
</ul>
</li>
<li>I/O总线——低速I/O设备之间互相连接的总线</li>
</ul>
</li>
<li>总线结构<ul>
<li>单总线——争用唯一的总线，但不是只有一根</li>
<li>双(多)总线——将低速的I/O设备从单总线上分离出来，实现I/O总线</li>
</ul>
</li>
<li>总线性能指标<ul>
<li>总线带宽——总线本身所能达到的最高传输速率</li>
<li>总线频率——</li>
<li>总线宽度——总线上能够同时传输的数据位数，通常指数据总线的根数</li>
</ul>
</li>
<li>总线仲裁<ul>
<li>集中式仲裁<ul>
<li>链式查询方式<ul>
<li>离总线仲裁器最近的设备具有最高优先级、优先级固定</li>
<li>对电路故障很敏感</li>
<li>3根（总线请求1，总线忙1，总线允许1）</li>
</ul>
</li>
<li>计数器定时查询方式<ul>
<li>log2(n)+2</li>
<li>计数器可以从0开始，也可以从上一次的终点开始，循环方法，此时设备使用总线的优先级相等</li>
</ul>
</li>
<li>独立请求方式<ul>
<li>2n+1（总线请求n，总线允许n，总线忙1）</li>
<li>响应速度快</li>
</ul>
</li>
</ul>
</li>
<li>分布式仲裁<ul>
<li>每个潜在的主模块都有自己的仲裁号和仲裁器</li>
</ul>
</li>
</ul>
</li>
<li>总线操作和定时<ul>
<li>总线的一次信息传送过程：5个步骤<ul>
<li>请求总线</li>
<li>总线仲裁</li>
<li>寻址</li>
<li>信息传送</li>
<li>状态返回</li>
</ul>
</li>
<li>同步定时——系统使用同一的时钟信号来协调发送和接收双方的传送定时关系。<ul>
<li>传送速度快</li>
<li>适用于总线长度较短及部件的存取时间比较接近的系统</li>
</ul>
</li>
<li>异步定时<ul>
<li>没有统一的时钟</li>
<li>依靠传送双方的握手来实现定时控制</li>
<li>总线长度可变，能保证速度相差很大的部件之间进行信息交换</li>
<li>请求和回答信号的互锁<ul>
<li>不互锁</li>
<li>半互锁</li>
<li>全互锁</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>总线标准<ul>
<li>ISA</li>
<li>PCI</li>
<li>USB</li>
<li>SCSI</li>
<li>SATA</li>
</ul>
</li>
</ul>
<h2 id="第7章"><a href="#第7章" class="headerlink" title="第7章"></a>第7章</h2><ul>
<li>存储区域<ul>
<li>磁盘有若干个记录面，每个记录面分为若干磁道，每条磁道分为若干扇区（块），块是磁盘读写的最小单位。</li>
<li>记录面数</li>
<li>柱面数</li>
<li>扇区数</li>
<li>磁道的编址从外向内依次编址</li>
</ul>
</li>
<li>性能指标<ul>
<li>磁盘容量</li>
<li>存储密度<ul>
<li>道密度</li>
<li>位密度</li>
<li>面密度=位密度*道密度</li>
</ul>
</li>
<li>平均存取时间<ul>
<li>T=平均找道时间+平均等待时间（1/2r)+数据传送时间(b/rN)，其中r：磁盘旋转率，N：每道字节数，b：传送的字节数</li>
</ul>
</li>
<li>数据传输率<ul>
<li>Dr=nN，其中n：磁盘旋转率，N：每条磁道容量的字节数</li>
<li>Dr=D*v，D：位密度，v：磁盘旋转的线速度 </li>
</ul>
</li>
</ul>
</li>
<li>同一柱面不需要重新找道，节省时间</li>
<li>显示设备 <ul>
<li>分辨率——显示器所能显示的像素个数</li>
<li>灰度级——显示的像素点的亮暗差别</li>
<li>视频存储器（显存）：容量M=分辨率r * 灰度级C</li>
</ul>
</li>
</ul>
<h2 id="第8章"><a href="#第8章" class="headerlink" title="第8章"></a>第8章</h2><ul>
<li>信息交换方式<ul>
<li>程序查询方式</li>
<li>程序中断方式</li>
<li>直接访问内存方式（DMA）<ul>
<li>仍然考虑中断响应</li>
<li>DMA控制器从CPU完全接管对总线的控制，数据交换不经过CPU，直接在内存和外围设备之间进行</li>
</ul>
</li>
<li>通道方式<ul>
<li>CPU把部分权利下放给通道</li>
<li>通道是一个具有特殊功能的处理器</li>
<li>优先权高于CPU</li>
</ul>
</li>
</ul>
</li>
<li>中断方式<ul>
<li>程序中断是指在计算机在执行现有程序的过程中，出现异常情况或特殊请求，CPU暂时中止现行程序，转而去处理这些请求，处理完毕后自动返回到断点处继续执行原有程序</li>
<li>CPU响应中断的条件<ul>
<li>有中断请求</li>
<li>CPU允许中断及开中断</li>
<li>一条指令执行完毕执行</li>
</ul>
</li>
<li>中断向量<ul>
<li>每个中断程序都有一个入口地址，CPU必须找到这个入口地址，即中断向量<ul>
<li>中断向量地址——入口地址的地址</li>
</ul>
</li>
</ul>
</li>
<li>中断隐指令（硬件自动完成）<ul>
<li>关中断</li>
<li>保存断点</li>
<li>引出中断服务程序</li>
</ul>
</li>
<li>中断服务程序完成<ul>
<li>保护现场和屏蔽字</li>
<li>开中断</li>
<li>恢复现场和屏蔽字</li>
<li>中断返回</li>
</ul>
</li>
<li>中断额外开销时间=中断系统响应时间+软件额外开销</li>
<li>最短中断时间间隔=响应时间+中断服务程序时间</li>
<li>CPI执行轨迹图，参考例题</li>
</ul>
</li>
<li>DMA<ul>
<li>数据传送不经CPU</li>
<li>DMA控制器——对数据传输过程中进行控制的硬件<ul>
<li>主要功能</li>
<li>接收外设发出的DMA请求，并向CPU发出总线请求</li>
<li>CPU响应后，DMA控制器接管总线控制权</li>
<li>DMA控制器对内存寻址，执行数据传送的操作</li>
<li>向CPU报告DMA操作的结束</li>
</ul>
</li>
<li>DMA传送方式<ul>
<li>停止CPU访问主存</li>
<li>DMA和CPU交替访存</li>
<li>周期挪用</li>
</ul>
</li>
<li>选择型DMA——在某段时间内只能为一个设备服务</li>
<li>多路型DMA——能同时为多个慢速外围设备服务</li>
</ul>
</li>
<li>中断和DMA的区别<ul>
<li>DMA除了预处理和后处理，其他时候不占用CPU资源</li>
<li>对中断请求的响应发生在每条指令执行完毕时，对DMA请求的响应可以发生在每个机器周期（取指周期、间指周期…）结束时，只要CPU不占用总线就可以   </li>
<li>DMA请求的优先权高于中断请求</li>
</ul>
</li>
<li>通道方式<ul>
<li>选择通道——一段时间只能一个设备工作<ul>
<li>最大数据传输率：F=max(fi)</li>
</ul>
</li>
<li>多路通道<ul>
<li>数组多路通道——一段时间内能交替执行多个设备，高速设备。但只允许一个设备进行传输型操作</li>
<li>F=max(fi)</li>
<li>字节多路通道——主要用于连接大量低速设备，允许多个设备进行传输型操作</li>
<li>F=f1+f2+…</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lujiamin.github.io/2017/06/14/PrincipleOfComputerOrg/" data-id="cj4405dex000atsopznc43b8p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/review/">review</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/06/14/DataBase/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          the review of the DataBase
        
      </div>
    </a>
  
  
    <a href="/2017/06/04/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/review/">review</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/review/" style="font-size: 10px;">review</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/19/CompilePrinciple/">the Points of Compile Principle</a>
          </li>
        
          <li>
            <a href="/2017/06/19/NetPoints/">the Points of Computer Network</a>
          </li>
        
          <li>
            <a href="/2017/06/16/ComputerNetwork/">the review of Computer Network</a>
          </li>
        
          <li>
            <a href="/2017/06/14/DataBase/">the review of the DataBase</a>
          </li>
        
          <li>
            <a href="/2017/06/14/PrincipleOfComputerOrg/">the review of the Principle of Computer Organization</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 lujiamin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>