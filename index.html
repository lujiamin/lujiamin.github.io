<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="blog">
<meta property="og:url" content="https://lujiamin.github.io/index.html">
<meta property="og:site_name" content="blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="blog">
  
    <link rel="alternate" href="/atom.xml" title="blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://lujiamin.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-DataBase" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/14/DataBase/" class="article-date">
  <time datetime="2017-06-14T11:05:00.000Z" itemprop="datePublished">2017-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/14/DataBase/">the review of the DataBase</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第1章"><a href="#第1章" class="headerlink" title="第1章"></a>第1章</h2><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>DB</li>
<li>DBMS</li>
<li>DBS</li>
<li>DBA</li>
<li>三层模式和两级映像<ul>
<li>DB的数据结构<ul>
<li>逻辑模式</li>
<li>外模式</li>
<li>内模式</li>
</ul>
</li>
<li>两级映像</li>
</ul>
</li>
</ul>
<h2 id="第2章"><a href="#第2章" class="headerlink" title="第2章"></a>第2章</h2><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>关键码<ul>
<li>超键</li>
<li>候选键</li>
<li>主键</li>
<li>外键</li>
</ul>
</li>
<li>关系模型的3类完整性规则<ul>
<li>实体完整性</li>
<li>参照完整性</li>
<li>用户定义的完整性规则</li>
</ul>
</li>
<li>关系模型的3层体系结构<ul>
<li>关系模式</li>
<li>子模式</li>
<li>存储模式 </li>
</ul>
</li>
</ul>
<h4 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h4><ul>
<li>5个基本操作<ul>
<li>并</li>
<li>差</li>
<li>笛卡尔积</li>
<li>投影</li>
<li>选择</li>
</ul>
</li>
<li>4个组合操作<ul>
<li>交</li>
<li>连接</li>
<li>自然连接</li>
<li>除法</li>
</ul>
</li>
</ul>
<h4 id="启发式算法"><a href="#启发式算法" class="headerlink" title="启发式算法"></a>启发式算法</h4><ul>
<li>3个规则<ul>
<li>尽可能早地执行选择操作</li>
<li>尽可能早地执行投影操作</li>
<li>避免直接做笛卡尔积</li>
</ul>
</li>
</ul>
<h2 id="第3章"><a href="#第3章" class="headerlink" title="第3章"></a>第3章</h2><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><ul>
<li>组成（4部分）<ul>
<li>DDL（定义模式、基本表、视图、索引）</li>
<li>DML（查询、修改、删除、插入）</li>
<li>DCL（授权、完整性约束、事务）</li>
<li>嵌入式SQL语言</li>
</ul>
</li>
<li>SQL数据定义<ul>
<li>模式的撤销——drop schema xxx [cascade|restrict].</li>
<li>基本数据类型</li>
<li>基本表<ul>
<li>create table xxx();</li>
<li>alter table xxx [add|drop|modify] yyy;</li>
<li>drop table xxx [cascade|restrict];</li>
</ul>
</li>
<li>索引<ul>
<li>create index xxx on …;</li>
<li>drop index xxx;</li>
</ul>
</li>
</ul>
</li>
<li>SQL数据查询<ul>
<li>基本句型——select A1,A2… from R1,R2… where … having … group by … order by ..[asc|desc]</li>
<li>select 后的内容必须是group by后面内容的子集</li>
<li>where 子句中不能直接使用聚合函数</li>
<li>and | or | not</li>
<li>in | not in </li>
<li>exists | all | some | unique</li>
<li>语句嵌套</li>
<li>聚合函数——count(*),count(xx),sum(xx),avg(xx),max(xx),min(xx)</li>
<li>聚合函数中除了count(*)以外，其余都会跳过值</li>
<li>导出表的使用</li>
</ul>
</li>
<li>SQL数据插入<ul>
<li>insert into xxx values(…);</li>
</ul>
</li>
<li>SQL数据删除<ul>
<li>delete from xxx where …;</li>
</ul>
</li>
<li>SQL数据修改<ul>
<li>update xxx set … where …;</li>
</ul>
</li>
<li>视图<ul>
<li>create view xxx(…) as select …;</li>
<li>drop view xxx;</li>
<li>定义时加上 with check option后才允许用户更新视图</li>
</ul>
</li>
</ul>
<h2 id="第4章"><a href="#第4章" class="headerlink" title="第4章"></a>第4章</h2><h4 id="函数依赖-FD"><a href="#函数依赖-FD" class="headerlink" title="函数依赖(FD)"></a>函数依赖(FD)</h4><ul>
<li>函数依赖的定义</li>
<li>推理规则<ul>
<li>自反性、增广性、传递性、合并性、分解性、伪传递性、复合性</li>
</ul>
</li>
<li>非平凡的FD</li>
<li>FD和关键码的联系<ul>
<li>超键（能退出完整属性集）</li>
<li>候选键（任一真子集都无法推出完整的属性集）</li>
</ul>
</li>
<li>属性集的闭包<ul>
<li>X→Y能用 FD 推理规则推出的充分必要条件是Y∈X+</li>
</ul>
</li>
<li>FD推理规则的完备性<ul>
<li>正确性保证了推出的所有FD是正确的，完备性保证了可以推出所有被蕴涵的FD</li>
</ul>
</li>
<li>FD集的最小依赖集<ul>
<li>每个FD右边都是单属性</li>
<li>没有冗余的FD</li>
<li>FD左边没有冗余的属性</li>
</ul>
</li>
</ul>
<h4 id="关系模式的分解特性"><a href="#关系模式的分解特性" class="headerlink" title="关系模式的分解特性"></a>关系模式的分解特性</h4><ul>
<li>无损分解<ul>
<li>损失分解指丢失信息，产生寄生元组，而不是元组的丢失</li>
</ul>
</li>
<li>判断无损分解的测试方法<ul>
<li>表格法</li>
<li>p={R1，R2}是无损分解的充分必要条件是 （R1 ∩ R2 → R1-R2 或者 R1 ∩ R2 → R2-R1 ）</li>
</ul>
</li>
<li>保持函数依赖的分解</li>
</ul>
<h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><ul>
<li>1NF</li>
<li>2NF——每个非主属性完全依赖于候选键<ul>
<li>局部依赖的定义</li>
<li>分解成2NF的算法——例：关系模式R(ABC)，F={AB-&gt;C,A-&gt;C}分解成p={AC,AB}</li>
</ul>
</li>
<li>3NF——每个非主属性都不传递依赖于候选键<ul>
<li>对于每个FD X-&gt;Y，都有X是R的超键或者Y的每个属性都是主属性，则R是3NF</li>
<li>分解成3NF的算法——1)求最小依赖集，并将左部相同的合并. 2)将最小依赖集中 X-&gt;Y 构成一个模式 XY. 3)如果每个模式中都不包含候选键，则将候选键作为一个模式放入模式集中.</li>
</ul>
</li>
<li>BCNF——每个属性都不传递依赖于候选键<ul>
<li>对于每个FD X-&gt;Y，都有X是R的超键，则R是BCNF</li>
</ul>
</li>
</ul>
<h2 id="第5章"><a href="#第5章" class="headerlink" title="第5章"></a>第5章</h2><h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><ul>
<li>生存周期<ul>
<li>规划</li>
<li>需求分析</li>
<li>概念分析</li>
<li>逻辑分析</li>
<li>物理分析</li>
<li>数据库实现</li>
<li>数据库运行和维护</li>
</ul>
</li>
<li>各种模式的区别和对应关系<ul>
<li>关系模式 &lt;——&gt; 逻辑模式 &lt;——&gt; 模式名、属性名</li>
<li>子模式   &lt;——&gt; 外模式(view) &lt;——&gt; 用户对数据库进行操作的权限</li>
<li>存储模式 &lt;——&gt; 内模式(index) &lt;——&gt; 存储关系</li>
</ul>
</li>
</ul>
<h4 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h4><ul>
<li>基本元素<ul>
<li>实体（矩形框）</li>
<li>联系（菱形框）</li>
<li>属性（椭圆形）</li>
</ul>
</li>
<li>关系模式<ul>
<li>M:N或者M:N:P需要单独转化为关系模式</li>
</ul>
</li>
</ul>
<h2 id="第7章"><a href="#第7章" class="headerlink" title="第7章"></a>第7章</h2><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><ul>
<li>事务的ACID性质 <ul>
<li>原子性（A）</li>
<li>一致性（C）</li>
<li>隔离性（I）</li>
<li>持久性（D）</li>
</ul>
</li>
<li>事务结束的方法<ul>
<li>commit</li>
<li>rollback</li>
</ul>
</li>
</ul>
<h4 id="数据库的恢复"><a href="#数据库的恢复" class="headerlink" title="数据库的恢复"></a>数据库的恢复</h4><ul>
<li>故障类型<ul>
<li>事务故障</li>
<li>系统故障</li>
<li>介质故障</li>
</ul>
</li>
<li>检查点技术<ul>
<li>只有在检查点的时候才真正将修改写入磁盘</li>
<li>redo</li>
<li>undo</li>
</ul>
</li>
</ul>
<h4 id="数据库的并发控制"><a href="#数据库的并发控制" class="headerlink" title="数据库的并发控制"></a>数据库的并发控制</h4><ul>
<li><p>并发带来的3个问题</p>
<ul>
<li>丢失更新问题</li>
<li>读脏数据问题</li>
<li>不可重复读问题</li>
</ul>
</li>
<li><p>封锁技术</p>
<ul>
<li>排他型封锁（X锁）——不允许其他事务再对该数据加任何类型的锁</li>
<li>共享型封锁（S锁）——允许其他事务对该数据加S锁，但不允许任何事务对该数据加X锁</li>
<li>使用S锁的操作有3个：<ul>
<li>申请S锁</li>
<li>升级和写操作</li>
<li>解除S锁</li>
</ul>
</li>
<li>封锁的粒度——封锁对象的大小称为封锁的粒度</li>
<li>封锁协议<ul>
<li>一级封锁协议——防止丢失更新</li>
<li>二级封锁协议——防止丢失更新、防止读脏数据</li>
<li>三级封锁协议——防止丢失更新、防止读脏数据、防止不可重复读</li>
</ul>
</li>
</ul>
</li>
<li><p>封锁带来的问题</p>
<ul>
<li>活锁——使某个事务永远处于等待状态</li>
<li>饿死——某事务永远轮不上封锁的机会</li>
<li>死锁——几个事务都处于等待状态，且需要另一个事务解除封锁才能够继续执行</li>
</ul>
</li>
<li><p>并发操作的调度</p>
<ul>
<li>串行调度——事务串行调度的结果都是正确的</li>
<li>可串行化的调度——一个并发调度的执行结果和某一个串行调度的执行结果等价</li>
</ul>
</li>
<li><p>SQL对事务并发处理的支持</p>
<ul>
<li>事务的存取模式<ul>
<li>read only（只读型）——事务对数据库的操作只能是读操作。</li>
<li>read write（读写型）——事务对数据库的操作可以是读操作，也可以是写操作</li>
<li>SQL定义语句：set transaction read only</li>
</ul>
</li>
<li>事务的隔离级别 （从高到低）<ul>
<li>serializable（可串行化）</li>
<li>repeatable read（可重复读）</li>
<li>read committed（读提交数据）</li>
<li>read uncommitted（可以读未提交数据）</li>
<li>SQL语句：set transaction isolation level serializable</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数据库的完整性"><a href="#数据库的完整性" class="headerlink" title="数据库的完整性"></a>数据库的完整性</h4><ul>
<li>完整性概念<ul>
<li>正确性</li>
<li>有效性</li>
<li>相容性</li>
<li>防止错误的数据进入数据库</li>
</ul>
</li>
<li>SQL中的完整性约束<ul>
<li>域约束<ul>
<li>create domain xxx char(6) default ‘??’ constraint yyy check();</li>
</ul>
</li>
<li>基本表约束<ul>
<li>候选键（unique）和主键（primary key）</li>
<li>外键参照动作<ul>
<li>no action</li>
<li>cascade </li>
<li>restrict</li>
<li>set null</li>
<li>set default </li>
</ul>
</li>
<li>检查约束的定义<ul>
<li>check语句 </li>
</ul>
</li>
</ul>
</li>
<li>断言<ul>
<li>SQL语句：create assertion ass1 check（…）;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数据库的安全性"><a href="#数据库的安全性" class="headerlink" title="数据库的安全性"></a>数据库的安全性</h4><ul>
<li>安全性级别<ul>
<li>环境级</li>
<li>职员级</li>
<li>os级</li>
<li>网络级</li>
<li>DBS级</li>
</ul>
</li>
<li>访问数据的权限（4个）<ul>
<li>读（read）</li>
<li>插入（insert）</li>
<li>修改（update）</li>
<li>删除（delete）</li>
</ul>
</li>
<li>修改数据库模式的权限（4个）<ul>
<li>索引（index）</li>
<li>资源（resource）</li>
<li>修改（alteration）</li>
<li>撤销（drop）</li>
</ul>
</li>
<li>SQL中的安全机制<ul>
<li>视图</li>
<li>权限<ul>
<li>授权语句<ul>
<li>grant select，update on S to  Wang with grant option</li>
<li>把对关系S的查询、修改权限授权给用户Wang，并且Wang还可以把这些权限转授给其他用户</li>
<li>to public 表示授权给所有用户</li>
<li>references （T#）引用其他关系的主键作为外键</li>
</ul>
</li>
<li>回收语句<ul>
<li>revoke select，update on S from Wang cascade</li>
<li>从用户Wang回收对关系S的查询、修改权，并且是级联回收</li>
<li>revoke grant option for references（C#）on C from BAO</li>
<li>从用户BAO回收对关系C中主键C#引用的转授权</li>
<li>revoke grant option for 用于回收转授权</li>
</ul>
</li>
<li>谁授权，由谁回收</li>
<li>权限操作中，查询不能加列名表，更新(update)可以加列名表</li>
</ul>
</li>
<li>角色</li>
<li>审计——用于安全性目的的数据库日志称为审计追踪</li>
</ul>
</li>
</ul>
<h2 id="第10章"><a href="#第10章" class="headerlink" title="第10章"></a>第10章</h2><h4 id="ODBC句柄"><a href="#ODBC句柄" class="headerlink" title="ODBC句柄"></a>ODBC句柄</h4><ul>
<li>ODBC有3个句柄<ul>
<li>环境句柄——定义了一个数据库环境（只有1个）</li>
<li>连接句柄——定义了一个数据库连接</li>
<li>语句句柄——定义了一条SQL语句</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lujiamin.github.io/2017/06/14/DataBase/" data-id="cj3ww4h4h0000vkop0x5kptxt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/review/">review</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-PrincipleOfComputerOrg" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/14/PrincipleOfComputerOrg/" class="article-date">
  <time datetime="2017-06-14T11:00:00.000Z" itemprop="datePublished">2017-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/14/PrincipleOfComputerOrg/">the review of the Principle Computer Organization</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第1章"><a href="#第1章" class="headerlink" title="第1章"></a>第1章</h2><ul>
<li>计算机性能指标<ul>
<li>机器字长——计算机一次整数运算能够处理的二进制数据的位数</li>
<li>主频、时钟周期</li>
<li>CPI（每条指令周期数）——Clock cycle Per Instruction</li>
<li>MIPS（每秒执行多少百万条定点指令数）——Million Instructions Per Second</li>
<li>FLOPS（每秒执行浮点操作的次数）</li>
</ul>
</li>
<li>传统冯诺依曼体系是单指令流和单数据流系统<ul>
<li>存储器</li>
<li>运算器</li>
<li>控制器</li>
<li>输入设备</li>
<li>输出设备</li>
<li>相关特点<ul>
<li>指令和数据按地址寻访</li>
<li>二进制代码</li>
</ul>
</li>
</ul>
</li>
<li>计算机功能部件<ul>
<li>主存储器<ul>
<li>MAR(地址寄存器)，其位数对应存储单元的个数</li>
<li>MDR(数据寄存器)，其位数和存储字长相等</li>
</ul>
</li>
<li>控制器<ul>
<li>IR(指令寄存器)，存放当前指令</li>
<li>PC(程序计数器)，存放当前欲执行指令的地址</li>
<li>CU(控制单元)  </li>
</ul>
</li>
<li>运算器<ul>
<li>核心是ALU(算术逻辑单元)，包含ACC(累加器)，IX(变址寄存器)，BR(基址寄存器)…</li>
</ul>
</li>
</ul>
</li>
<li>计算机能够直接执行的语言是：机器语言</li>
<li>用助记符编写的语言是：汇编语言</li>
<li>把汇编语言源程序转变为机器语言的过程称为：汇编</li>
</ul>
<h2 id="第2章"><a href="#第2章" class="headerlink" title="第2章"></a>第2章</h2><ul>
<li>进制的转换</li>
<li>校验码<ul>
<li>奇偶校验码<ul>
<li>只能发现数据代码中奇数位出错情况，但不能纠正错误</li>
</ul>
</li>
<li>海明码<ul>
<li>能够自动指出因为错误并纠错</li>
<li>n+k &lt;= 2^k-1，其中n：信息位位数，k：校验位位数</li>
<li>校验位分布在2^(i-1)位置上，即(1,2,4,8…)</li>
<li>校验位（P1，P2，P3…）的计算<ul>
<li>将数据位编成二进制，P1对应个位为1的数据位值的异或，P1对应十位为1的数据位值的异或…</li>
</ul>
</li>
<li>校验原理<ul>
<li>将整个海明码的每一位编成响应二进制数，对个位为1的海明码值求异或…，如果最终每一位对应的异或值都为0，则代表没有出错      </li>
</ul>
</li>
</ul>
</li>
<li>循环冗余校验码(CRC)<ul>
<li>原信息码补0，0的个数为多项式最高次数的值</li>
<li>补完0之后对多项式系数构成的二进制做除法取余</li>
<li>余数加至原信息码后面构成循环冗余码</li>
</ul>
</li>
</ul>
</li>
<li>定点数的表示<ul>
<li>原码（8位表示范围-127~127，存在+0和-0）</li>
<li>反码（8位表示范围-127~127，存在+0和-0）</li>
<li>补码（8位表示范围-128~127，0有唯一补码）</li>
<li>移码——补码符号位取反（8位表示范围-128~127），移码直观上反应真值大小</li>
<li>双符号位加减运算<ul>
<li>00，结果为正数，无溢出</li>
<li>01，正溢出</li>
<li>10，负溢出</li>
<li>11，结果为负数，无溢出</li>
</ul>
</li>
<li>原码一位乘法<ul>
<li>符号位和数值位分开</li>
<li>对应位为1则累加|x|，移位。对应位为0，则累加0，移位。</li>
</ul>
</li>
<li>补码一位乘法（Booth算法）<ul>
<li>符号位参与运算</li>
<li>乘数末尾补0，根据最后两位的值来判断操作</li>
<li>00——右移一位</li>
<li>01——累加[x]补，右移一位</li>
<li>10——累加[-x]补，右移一位</li>
<li>11——右移一位 </li>
<li>补码转化为真值</li>
</ul>
</li>
</ul>
</li>
<li>浮点数的表示<ul>
<li>IEEE754标准<ul>
<li>单精度（32位）：1位符号位（s）+8位阶码（E）+23位尾数（M）</li>
<li>E = 指数(e) + 127</li>
<li>1.M(隐藏为1的尾数)</li>
</ul>
</li>
<li>加减法<ul>
<li>0操作数检查</li>
<li>对阶——小阶向大阶对齐</li>
<li>尾数求和</li>
<li>规格化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第3章"><a href="#第3章" class="headerlink" title="第3章"></a>第3章</h2><ul>
<li>在计算机中的层次<ul>
<li>主存(内存)</li>
<li>辅存(外存)</li>
<li>高速缓冲存储器(cache)</li>
<li>cache——主存：解决速度问题，数据调动由硬件完成，对程序员透明</li>
<li>主存——辅存：解决容量问题，数据调动由硬件和操作系统完成，对应用程序员透明</li>
</ul>
</li>
<li>存储器的分类<ul>
<li>存储介质<ul>
<li>磁表面（磁带，磁盘）</li>
<li>磁芯半导体</li>
<li>光存储器（光盘）</li>
</ul>
</li>
<li>存取方式<ul>
<li>随机存储器</li>
<li>顺序存储器（磁带）</li>
<li>直接存储器（磁盘）——介于两者之间</li>
</ul>
</li>
<li>内容的可保存性<ul>
<li>ROM(只读存储器)</li>
<li>RAM(随机读写存储器)</li>
</ul>
</li>
</ul>
</li>
<li>存储器的性能指标<ul>
<li>存储容量、单位成本、存储速度</li>
<li>存储速度<ul>
<li>存取时间——启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间</li>
<li>存取周期——进行一次完整的读写操作所需的时间。即连续两次独立地访问存储器之间所需的最小时间间隔</li>
<li>通常：存储周期 &gt; 存取时间，原因是在读写操作之后有一段恢复内部状态的复原时间</li>
</ul>
</li>
<li>主存带宽——数据传输率 </li>
</ul>
</li>
<li>SRAM<ul>
<li>地址线 （字数）</li>
<li>数据线 （位数）</li>
<li>读写控制线</li>
</ul>
</li>
<li>DRAM<ul>
<li>刷新方式<ul>
<li>集中式刷新，利用一个固定的时间，对存储器的所有行进行逐一再生，这期间停止对存储器的读写操作</li>
<li>分散式刷新，没有死区</li>
</ul>
</li>
<li>存储器容量的扩充</li>
</ul>
</li>
<li>ROM<ul>
<li>掩模ROM</li>
<li>可编程ROM（PROM,EPROM,E2PROM）</li>
</ul>
</li>
<li>FLASH存储器<ul>
<li>是在EPROM上发展而来</li>
</ul>
</li>
<li>并行存储器<ul>
<li>双端口存储器<ul>
<li>左右两个独立的端口，具有相互独立的地址线、数据线和读写控制线</li>
<li>当两个端口的地址不相同时，两个端口进行读写操作一定不会发生冲突</li>
<li>使用同一个地址单元时，会造成冲突</li>
</ul>
</li>
<li>多模块交叉存储器<ul>
<li>高位交叉编址仍是顺序存储器</li>
<li>低位交叉编址则是交叉存储器</li>
<li>顺序方式：t = mT</li>
<li>交叉方式：t = T + (m-1)τ （其中T=mτ）</li>
<li>模块数必须大于等于m</li>
</ul>
</li>
</ul>
</li>
<li>cache<ul>
<li>cache命中率（h）</li>
<li>cache访问时间（Tc）</li>
<li>访问效率（e=Tc/Ta）</li>
<li>平均访问时间（Ta）</li>
<li>主存和cache的地址映射<ul>
<li>由于cache容量很小，需要将主存地址定位到cache中</li>
<li>全相联——可以装入cache中的任意位置<ul>
<li>地址结构：主存字块标记+字块内标记</li>
</ul>
</li>
<li>直接映射——主存数据块只能装入cache中的唯一位置。<ul>
<li>j = i % N （j：cache块号，i：主存块号，N：cache总块数）</li>
<li>地址结构：主存字块标记+cache字块标记+字块内地址</li>
</ul>
</li>
<li>组相联——组间直接映射，组内全相联<ul>
<li>地址结构：主存字块标记+组号+字块内地址</li>
</ul>
</li>
</ul>
</li>
<li>cache中主存块的替换算法<ul>
<li>LRU（最近最少使用）</li>
<li>LFU（最不经常使用）</li>
<li>随机替换</li>
</ul>
</li>
<li>cache的写操作策略<ul>
<li>写回法——CPU写命中cache时，只修改cache的内容，此行被换出时才写回主存</li>
<li>全写法——CPU写命中时，cache和主存同时发生写修改</li>
<li>写一次法——第一次写命中时同时写入主存</li>
</ul>
</li>
</ul>
</li>
<li>虚拟存储器<ul>
<li>逻辑地址和物理地址</li>
<li>页式虚拟存储<ul>
<li>虚拟空间和主存空间被划分成同样大小的页</li>
<li>页表——存放虚页号和实页号的对照表，一般放在内存中</li>
<li>查页表，需要访问一次主存</li>
</ul>
</li>
<li>段式虚拟存储<ul>
<li>段是按程序的逻辑结构来划分的，段的长度不一致</li>
<li>段号+段内地址</li>
</ul>
</li>
<li>段页式虚拟存储<ul>
<li>分段，每段在划分为相同大小的页</li>
<li>段号+段内页号+页内地址</li>
</ul>
</li>
<li>TLB（快表）——经常需要访问的页对应的页表放在高速缓冲器中</li>
<li>Page（慢表）——放在主存中的页表</li>
<li>TLB是Page的一个很小的副本</li>
<li>TLB命中，Page一定命中</li>
<li>Page不命中，cache和主存也不命中</li>
</ul>
</li>
</ul>
<h2 id="第4章"><a href="#第4章" class="headerlink" title="第4章"></a>第4章</h2><h4 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h4><ul>
<li>操作码</li>
<li>地址码</li>
<li>指令的长度——一条指令中包含二进制代码的位数</li>
<li>指令字长=操作码长度+地址码长度<ul>
<li>机器字长——计算机能够直接处理的二进制数据的位数，决定了计算机的精度。通常和主存单元的位数一致</li>
<li>单字长指令：指令长度=1*机器字长</li>
<li>双字长指令：指令长度=2*机器字长</li>
</ul>
</li>
<li>零地址指令、一地址指令、二地址指令、三地址指令、四地址指令</li>
<li>二地址指令根据操作数的物理位置<ul>
<li>存储器——存储器（SS）</li>
<li>寄存器——寄存器（RR）</li>
<li>寄存器——存储器（RS）</li>
</ul>
</li>
<li>若指令字长32位，操作码8位，一个地址字段占24位，则指令操作数的直接寻址范围为2^24=16M </li>
<li>指令周期——执行一条指令所需要的时间</li>
</ul>
<h4 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h4><ul>
<li>指令的寻址方式<ul>
<li>顺序寻址——使用程序计数器PC来计数</li>
<li>跳跃寻址</li>
</ul>
</li>
<li>数据的寻址方式<ul>
<li>隐含寻址——累加器ACC对单地址指令来说是隐含地址</li>
<li>立即数寻址——指令执行时间最短</li>
<li>直接寻址——形式地址A就是操作数的真实地址，即EA=A</li>
<li>间接寻址——指令的地址字段给出的是操作数有效地址所在存储单元的地址，即EA=(A)</li>
<li>寄存器寻址——在指令字中直接给出操作数所在寄存器的编号，EA=Ri</li>
<li>寄存器间接寻址——寄存器Ri中给出的是操作数所在主存单元的地址，EA=(Ri)</li>
<li>偏移寻址 <ul>
<li>相对寻址——PC的内容加上指令中形式地址A形成操作数的有效地址，EA=(PC)+A</li>
<li>基址寻址——基址寄存器BR的内容加上形式地址A形成操作数的有效地址，EA=(BR)+A</li>
<li>变址寻址——变址寄存器IX的内容加上形式地址A形成操作数的有效地址，EA=(IX)+A</li>
</ul>
</li>
<li>堆栈寻址 </li>
</ul>
</li>
</ul>
<h4 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h4><ul>
<li>复杂指令系统计算机CISC<ul>
<li>指令数目多</li>
<li>指令长度不一致、格式多、寻址方式不一致</li>
<li>使用频率相差较大</li>
<li>执行时间相差较大</li>
<li>控制器大多采用微程序控制 </li>
</ul>
</li>
<li>精简指令系统计算机RISC<ul>
<li>选取高频率使用的一些简单指令</li>
<li>长度固定、格式少、寻址方式少</li>
<li>只有load/store指令访存，其余指令在寄存器之间进行</li>
<li>CPU通用寄存器相当多</li>
<li>以硬布线控制为主、组合逻辑控制</li>
<li>采用指令流水线技术，大多在一个时钟周期内完成</li>
</ul>
</li>
</ul>
<h2 id="第5章"><a href="#第5章" class="headerlink" title="第5章"></a>第5章</h2><ul>
<li>CPU功能<ul>
<li>指令控制</li>
<li>操作控制</li>
<li>时间控制</li>
<li>数据加工</li>
<li>中断处理</li>
</ul>
</li>
<li>CPU组成<ul>
<li>运算器<ul>
<li>ALU、通用寄存器、数据缓冲寄存器、PSW</li>
</ul>
</li>
<li>控制器<ul>
<li>PC、IR、MAR、MDR、指令译码器</li>
</ul>
</li>
</ul>
</li>
<li>主要寄存器<ul>
<li>DR（数据缓冲寄存器）——暂时存放ALU运算结果</li>
<li>IR（指令寄存器）——保存当前正在执行的一条指令</li>
<li>PC（程序计数器）——保存下一条要执行的指令</li>
<li>AR（数据地址寄存器）——保存所访问数据cache存储器中单元的地址</li>
<li>通用寄存器</li>
<li>PSW（状态字寄存器）——各种条件代码（进位标志、溢出标志）</li>
</ul>
</li>
<li>数据通路<ul>
<li>数据在功能部件之间传送的路径称为数据通路</li>
<li>数据通路基本结构<ul>
<li>CPU内部单总线</li>
<li>CPU内部三总线</li>
<li>专用数据通路方式</li>
</ul>
</li>
</ul>
</li>
<li>指令周期<ul>
<li>构成：取指周期+间址周期+执行周期+中断周期，4个过程都有访存操作，目的不同<ul>
<li>取指：取指令</li>
<li>间址：取有效地址</li>
<li>执行：取操作数</li>
<li>中断：保存程序断点</li>
</ul>
</li>
<li>指令周期 &gt; 机器周期 &gt; 时钟周期(节拍T) </li>
<li>时钟周期是CPU操作的最基本单位</li>
<li>各指令的指令周期（MOV,LAD,ADD,STO,JMP）</li>
</ul>
</li>
<li>控制方式<ul>
<li>控制器的控制方式——控制不同操作序列时序信号的方法</li>
<li>同步控制</li>
<li>异步控制</li>
<li>联合控制</li>
</ul>
</li>
<li>控制器<ul>
<li>硬布线控制器，又称组合逻辑控制器，由复杂的组合逻辑门电路和触发器构成<ul>
<li>速度相对较快，原因是微程序控制每条微指令需要从控存中读取一次，影响速度，硬布线主要取决于电路延迟</li>
</ul>
</li>
<li>微程序控制器<ul>
<li>微命令——控制部件通过控制线向执行部件发送各种控制命令</li>
<li>微操作——执行部件接收微命令后进行的操作</li>
<li>微操作在执行部件中是最基本的操作<ul>
<li>相容性——同一个CPU周期内能够并行执行</li>
<li>相斥性——不能并行执行</li>
</ul>
</li>
<li>微指令——在一个CPU周期内，实现一定操作功能的微命令的组合，构成一条微指令</li>
<li>微程序——一条机器指令由多条微指令组成的序列来实现  </li>
<li>微程序控制器原理图<ul>
<li>控制存储器——用来存放实现全部指令系统的微程序</li>
<li>微指令寄存器</li>
<li>地址转移逻辑</li>
</ul>
</li>
<li>微指令周期——读出微指令的时间加上执行该条微指令的时间</li>
<li>为了保证整个机器控制信号的同步，可以将微指令周期设计成CPU周期时间相等</li>
<li>机器指令和微指令的关系<ul>
<li>一条及其指令对应一个微程序，微程序由若干微指令序列构成</li>
<li>机器指令与内存存储器相关，微指令和控制存储器相关</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>微程序设计是利用软件方法来设计硬件的一门技术  <ul>
<li>目标<ul>
<li>缩短微指令的长度</li>
<li>减小控制存储器的容量</li>
<li>提高微程序运行速度</li>
<li>有利于对微指令的修改</li>
<li>提高微程序设计的灵活性</li>
</ul>
</li>
<li>微指令编码<ul>
<li>直接表示法<ul>
<li>控制字段中的每一位表示一个微命令</li>
<li>优点：简单直观、便于直接用于控制</li>
<li>缺点：指令较长，是控制存储器容量较大</li>
</ul>
</li>
<li>编码表示法<ul>
<li>把互斥性微命令编为一组</li>
<li>对微命令进行编码，流出一个代码表示本段不发出微命令</li>
<li>增设微命令译码器</li>
</ul>
</li>
<li>混合表示法</li>
</ul>
</li>
<li>微指令的地址形成方法<ul>
<li>初始微地址的形成<ul>
<li>根据机器指令的操作码形成</li>
</ul>
</li>
<li>后继微地址的形成<ul>
<li>计数器方式，直接由微指令的下地址字段给出 <ul>
<li>简单、功能较弱、速度慢</li>
</ul>
</li>
<li>多路转移方式<ul>
<li>灵活、速度快、设计较为复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>微指令格式<ul>
<li>水平型微指令<ul>
<li>一次能定义并执行多个并行操作微命令的微指令</li>
<li>控制字段+判别测试字段+下地址</li>
</ul>
</li>
<li>垂直型<ul>
<li>微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能</li>
</ul>
</li>
<li>两者的比较<ul>
<li>水平型微指令并行操作能力强，效率高，灵活性强</li>
<li>水平型微指令执行一条指令的时间短</li>
<li>水平型微指令解释的指令的微程序，有微指令字较长而微程序较短的特点</li>
<li>垂直型微指令则相反，微指令字较短而微程序长</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>流水线<ul>
<li>线性流水线的时钟周期：τ=max{τi}+τl（其中τi表示过程段Si所需时间，τl表示延时）</li>
<li>k级过程段完成n个任务，流水线处理所需时钟周期数:T=k+(n-1)。而串行则需要时钟周期数：T=n*k</li>
<li>分类<ul>
<li>指令流水线</li>
<li>算术流水线</li>
<li>处理机流水线</li>
</ul>
</li>
<li>流水线中的主要问题<ul>
<li>资源相关——争用同一个功能部件所发生的冲突</li>
<li>数据相关——一条指令必须等另一条指令执行完才能执行</li>
<li>控制相关——由转移指令引起（执行转移指令后，可能顺序执行下一条，也可能转移到新的目标地址）<ul>
<li>延迟转移法</li>
<li>转移预测法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第6章"><a href="#第6章" class="headerlink" title="第6章"></a>第6章</h2><ul>
<li>总线<ul>
<li>总线是一组能为多个部件分时共享的公共信息传送线路</li>
<li>分时——同一时刻只允许有一个部件向总线发送信息</li>
<li>共享——某一时刻可以有多个部件从总线上接收信息</li>
</ul>
</li>
<li>总线分类<ul>
<li>片内总线（内部总线）——CPU内部连接各个寄存器和运算器的总线</li>
<li>系统总线——计算机系统内各部件（CPU，主存）之间连接的总线<ul>
<li>数据总线，双向传输</li>
<li>地址总线，单向传输</li>
<li>控制总线</li>
</ul>
</li>
<li>I/O总线——低速I/O设备之间互相连接的总线</li>
</ul>
</li>
<li>总线结构<ul>
<li>单总线——争用唯一的总线，但不是只有一根</li>
<li>双(多)总线——将低速的I/O设备从单总线上分离出来，实现I/O总线</li>
</ul>
</li>
<li>总线性能指标<ul>
<li>总线带宽——总线本身所能达到的最高传输速率</li>
<li>总线频率——</li>
<li>总线宽度——总线上能够同时传输的数据位数，通常指数据总线的根数</li>
</ul>
</li>
<li>总线仲裁<ul>
<li>集中式仲裁<ul>
<li>链式查询方式<ul>
<li>离总线仲裁器最近的设备具有最高优先级、优先级固定</li>
<li>对电路故障很敏感</li>
<li>3根（总线请求1，总线忙1，总线允许1）</li>
</ul>
</li>
<li>计数器定时查询方式<ul>
<li>log2(n)+2</li>
<li>计数器可以从0开始，也可以从上一次的终点开始，循环方法，此时设备使用总线的优先级相等</li>
</ul>
</li>
<li>独立请求方式<ul>
<li>2n+1（总线请求n，总线允许n，总线忙1）</li>
<li>响应速度快</li>
</ul>
</li>
</ul>
</li>
<li>分布式仲裁<ul>
<li>每个潜在的主模块都有自己的仲裁号和仲裁器</li>
</ul>
</li>
</ul>
</li>
<li>总线操作和定时<ul>
<li>总线的一次信息传送过程：5个步骤<ul>
<li>请求总线</li>
<li>总线仲裁</li>
<li>寻址</li>
<li>信息传送</li>
<li>状态返回</li>
</ul>
</li>
<li>同步定时——系统使用同一的时钟信号来协调发送和接收双方的传送定时关系。<ul>
<li>传送速度快</li>
<li>适用于总线长度较短及部件的存取时间比较接近的系统</li>
</ul>
</li>
<li>异步定时<ul>
<li>没有统一的时钟</li>
<li>依靠传送双方的握手来实现定时控制</li>
<li>总线长度可变，能保证速度相差很大的部件之间进行信息交换</li>
<li>请求和回答信号的互锁<ul>
<li>不互锁</li>
<li>半互锁</li>
<li>全互锁</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>总线标准<ul>
<li>ISA</li>
<li>PCI</li>
<li>USB</li>
<li>SCSI</li>
<li>SATA</li>
</ul>
</li>
</ul>
<h2 id="第7章"><a href="#第7章" class="headerlink" title="第7章"></a>第7章</h2><ul>
<li>存储区域<ul>
<li>磁盘有若干个记录面，每个记录面分为若干磁道，每条磁道分为若干扇区（块），块是磁盘读写的最小单位。</li>
<li>记录面数</li>
<li>柱面数</li>
<li>扇区数</li>
<li>磁道的编址从外向内依次编址</li>
</ul>
</li>
<li>性能指标<ul>
<li>磁盘容量</li>
<li>存储密度<ul>
<li>道密度</li>
<li>位密度</li>
<li>面密度=位密度*道密度</li>
</ul>
</li>
<li>平均存取时间<ul>
<li>T=平均找道时间+平均等待时间（1/2r)+数据传送时间(b/rN)，其中r：磁盘旋转率，N：每道字节数，b：传送的字节数</li>
</ul>
</li>
<li>数据传输率<ul>
<li>Dr=nN，其中n：磁盘旋转率，N：每条磁道容量的字节数</li>
<li>Dr=D*v，D：位密度，v：磁盘旋转的线速度 </li>
</ul>
</li>
</ul>
</li>
<li>同一柱面不需要重新找道，节省时间</li>
<li>显示设备 <ul>
<li>分辨率——显示器所能显示的像素个数</li>
<li>灰度级——显示的像素点的亮暗差别</li>
<li>视频存储器（显存）：容量M=分辨率r * 灰度级C</li>
</ul>
</li>
</ul>
<h2 id="第8章"><a href="#第8章" class="headerlink" title="第8章"></a>第8章</h2><ul>
<li>信息交换方式<ul>
<li>程序查询方式</li>
<li>程序中断方式</li>
<li>直接访问内存方式（DMA）<ul>
<li>仍然考虑中断响应</li>
<li>DMA控制器从CPU完全接管对总线的控制，数据交换不经过CPU，直接在内存和外围设备之间进行</li>
</ul>
</li>
<li>通道方式<ul>
<li>CPU把部分权利下放给通道</li>
<li>通道是一个具有特殊功能的处理器</li>
<li>优先权高于CPU</li>
</ul>
</li>
</ul>
</li>
<li>中断方式<ul>
<li>程序中断是指在计算机在执行现有程序的过程中，出现异常情况或特殊请求，CPU暂时中止现行程序，转而去处理这些请求，处理完毕后自动返回到断点处继续执行原有程序</li>
<li>CPU响应中断的条件<ul>
<li>有中断请求</li>
<li>CPU允许中断及开中断</li>
<li>一条指令执行完毕执行</li>
</ul>
</li>
<li>中断向量<ul>
<li>每个中断程序都有一个入口地址，CPU必须找到这个入口地址，即中断向量<ul>
<li>中断向量地址——入口地址的地址</li>
</ul>
</li>
</ul>
</li>
<li>中断隐指令（硬件自动完成）<ul>
<li>关中断</li>
<li>保存断点</li>
<li>引出中断服务程序</li>
</ul>
</li>
<li>中断服务程序完成<ul>
<li>保护现场和屏蔽字</li>
<li>开中断</li>
<li>恢复现场和屏蔽字</li>
<li>中断返回</li>
</ul>
</li>
<li>中断额外开销时间=中断系统响应时间+软件额外开销</li>
<li>最短中断时间间隔=响应时间+中断服务程序时间</li>
<li>CPI执行轨迹图，参考例题</li>
</ul>
</li>
<li>DMA<ul>
<li>数据传送不经CPU</li>
<li>DMA控制器——对数据传输过程中进行控制的硬件<ul>
<li>主要功能</li>
<li>接收外设发出的DMA请求，并向CPU发出总线请求</li>
<li>CPU响应后，DMA控制器接管总线控制权</li>
<li>DMA控制器对内存寻址，执行数据传送的操作</li>
<li>向CPU报告DMA操作的结束</li>
</ul>
</li>
<li>DMA传送方式<ul>
<li>停止CPU访问主存</li>
<li>DMA和CPU交替访存</li>
<li>周期挪用</li>
</ul>
</li>
<li>选择型DMA——在某段时间内只能为一个设备服务</li>
<li>多路型DMA——能同时为多个慢速外围设备服务</li>
</ul>
</li>
<li>中断和DMA的区别<ul>
<li>DMA除了预处理和后处理，其他时候不占用CPU资源</li>
<li>对中断请求的响应发生在每条指令执行完毕时，对DMA请求的响应可以发生在每个机器周期（取指周期、间指周期…）结束时，只要CPU不占用总线就可以   </li>
<li>DMA请求的优先权高于中断请求</li>
</ul>
</li>
<li>通道方式<ul>
<li>选择通道——一段时间只能一个设备工作<ul>
<li>最大数据传输率：F=max(fi)</li>
</ul>
</li>
<li>多路通道<ul>
<li>数组多路通道——一段时间内能交替执行多个设备，高速设备。但只允许一个设备进行传输型操作</li>
<li>F=max(fi)</li>
<li>字节多路通道——主要用于连接大量低速设备，允许多个设备进行传输型操作</li>
<li>F=f1+f2+…</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lujiamin.github.io/2017/06/14/PrincipleOfComputerOrg/" data-id="cj3ww4h4x0001vkopm2l1jo7l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/review/">review</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/04/hello-world/" class="article-date">
  <time datetime="2017-06-03T16:13:26.335Z" itemprop="datePublished">2017-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/04/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lujiamin.github.io/2017/06/04/hello-world/" data-id="cj3ww4h4x0003vkopr3zhcmvt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/review/">review</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/review/" style="font-size: 10px;">review</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/14/DataBase/">the review of the DataBase</a>
          </li>
        
          <li>
            <a href="/2017/06/14/PrincipleOfComputerOrg/">the review of the Principle Computer Organization</a>
          </li>
        
          <li>
            <a href="/2017/06/04/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 lujiamin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>